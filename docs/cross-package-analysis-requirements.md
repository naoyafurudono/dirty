# クロスパッケージ解析の要件定義

## 概要

dirtyツールをパッケージ境界を越えて動作させるための要件定義書。現在の単一パッケージ解析から、プロジェクト全体のエフェクト追跡へと拡張する。

## 現状の課題

1. **パッケージ境界での追跡不能**
   - 他パッケージの関数呼び出しのエフェクトが追跡されない
   - インポートされた関数の`// dirty:`宣言が読み取れない

2. **型情報の欠如**
   - AST解析のみで、go/typesを使用していない
   - パッケージ修飾子やレシーバー型が正確に識別できない

3. **スケーラビリティ**
   - 大規模プロジェクトでの解析性能
   - 依存関係の深いプロジェクトでの解析時間

## 機能要件

### 1. パッケージ間のエフェクト伝播

- インポートされた関数のエフェクトを正確に追跡
- 標準ライブラリ関数のエフェクト定義サポート
- サードパーティライブラリのエフェクト定義サポート

### 2. 型情報の活用

- go/typesパッケージを使用した正確な型解析
- メソッドレシーバーの型情報を含む完全修飾名での識別
- インターフェース経由の呼び出し追跡

### 3. エフェクト情報の永続化

- 解析済みパッケージのエフェクト情報のキャッシュ
- ビルドキャッシュとの統合検討
- インクリメンタル解析のサポート

### 4. 設定とカスタマイズ

- プロジェクトレベルの設定ファイル（dirty.yaml等）
- 解析対象パッケージの指定
- 除外パターンの設定

## 技術要件

### 1. 解析エンジンの拡張

```go
type PackageAnalyzer struct {
    // 現在のパッケージ情報
    currentPkg *types.Package
    
    // インポートされたパッケージの解析結果
    importedEffects map[string]*PackageEffects
    
    // 型チェッカー
    typeChecker *types.Checker
}

type PackageEffects struct {
    // パッケージパス
    Path string
    
    // 関数・メソッドのエフェクト
    Functions map[EffectKey]*EffectSet
    
    // 解析タイムスタンプ
    AnalyzedAt time.Time
}
```

### 2. 解析フロー

1. **エントリーポイントの解析**
   - 指定されたパッケージから解析開始
   - go.modから依存関係を読み取り

2. **依存パッケージの解析**
   - インポートグラフの構築
   - 依存順序での解析実行
   - 循環依存の適切な処理

3. **エフェクト情報の統合**
   - 各パッケージのエフェクトを収集
   - クロスパッケージでの整合性チェック

### 3. パフォーマンス最適化

- 並列解析のサポート
- キャッシュシステムの実装
- 差分解析の実装

## 実装アプローチ

### Phase 1: 型システムの統合
- go/typesを使用した正確な型解析の実装
- 関数・メソッドの完全修飾名での識別
- 既存テストの型情報対応

### Phase 2: 基本的なクロスパッケージ解析
- 直接インポートされたパッケージの解析
- エフェクト情報の伝播
- JSON Effects V2との統合

### Phase 3: 高度な機能
- キャッシュシステムの実装
- インクリメンタル解析
- 大規模プロジェクト対応

## 使用例

```go
// pkg1/db.go
package pkg1

// dirty: { select[users] }
func GetUser(id int) User { ... }

// pkg2/service.go
package pkg2

import "pkg1"

// dirty: { select[users] | transform }  // pkg1.GetUserのエフェクトも宣言必要
func ProcessUser(id int) ProcessedUser {
    user := pkg1.GetUser(id)  // エフェクトが正しく伝播される
    return transform(user)
}
```

## 設定ファイル例

```yaml
# dirty.yaml
version: 1
packages:
  # 解析対象のパッケージパターン
  include:
    - "github.com/myproject/..."
    - "github.com/mylib/..."
  
  # 除外パターン
  exclude:
    - "**/*_test.go"
    - "**/vendor/**"

# エフェクト定義の外部ファイル
effects:
  - "effects/stdlib.json"
  - "effects/thirdparty.json"

# キャッシュ設定
cache:
  enabled: true
  directory: ".dirty-cache"
  ttl: "24h"
```

## 非機能要件

1. **互換性**
   - 既存の単一パッケージ解析との後方互換性
   - Go 1.21以降のサポート

2. **パフォーマンス**
   - 中規模プロジェクト（100パッケージ）で1分以内
   - メモリ使用量の最適化

3. **エラーハンドリング**
   - 部分的な解析失敗でも継続可能
   - 明確なエラーメッセージ

## まとめ

クロスパッケージ解析の実装により、dirtyツールは実用的なプロジェクトで使用可能となる。段階的な実装アプローチにより、各フェーズで価値を提供しながら最終的な目標を達成する。