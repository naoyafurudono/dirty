# JSON-based Effect Declarations Example

This example demonstrates how to use JSON files to declare effects for functions that may be:
- Generated by external tools (like SQLC)
- Part of external libraries
- Functions where you cannot modify the source code

## Files

- `dirty-effects.json` - JSON file containing effect declarations
- `example.go` - Example code using the functions declared in JSON

## How it works

1. The `dirty-effects.json` file declares effects for various functions:
   ```json
   {
     "GetUserFromDB": "{ select[users] }",
     "CreateUserInDB": "{ insert[users] | insert[audit_logs] }",
     ...
   }
   ```

2. When dirty analyzes the code, it reads this JSON file and treats these declarations as if they were written in the source code.

3. Functions in the source code must declare all effects from functions they call, including those defined in JSON.

## Running the example

From this directory:

```bash
# The JSON file will be automatically detected in the package directory
dirty .

# Or explicitly specify the JSON file
DIRTY_EFFECTS_JSON=dirty-effects.json dirty .
```

## Expected output

The analyzer will report an error for `ProcessUserUpdate` because it doesn't declare the `insert[audit_logs]` effect from `UpdateUserStatusInDB`:

```
example.go:40:9: function calls UpdateUserStatusInDB which has effects [insert[audit_logs], update[users]] not declared in this function
```

## Integration with external tools

This approach is particularly useful for integrating with code generation tools. For example, you could:

1. Use a tool like `sqlc-use` to analyze database queries
2. Transform its output to the dirty JSON format
3. Run dirty to ensure your code correctly declares all database effects

Example transformation script:
```bash
sqlc-use analyze | jq '{
  version: "1.0",
  effects: (
    to_entries | map({
      key: .key,
      value: ("{ " + (
        .value | map("\(.operation)[\(.table)]") | join(" | ")
      ) + " }")
    }) | from_entries
  )
}' > dirty-effects.json
```
