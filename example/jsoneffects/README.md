# Effect Registry Example

This example demonstrates how to use the Effect Registry to declare effects for functions that may be:
- Generated by external tools
- Part of external libraries
- Functions where you cannot modify the source code

## Files

- `effect-registry.json` - Effect Registry file containing effect declarations
- `example.go` - Example code using the functions declared in JSON

## How it works

1. The `effect-registry.json` file declares effects for various functions:
   ```json
   {
     "GetUserFromDB": "{ select[users] }",
     "CreateUserInDB": "{ insert[users] | insert[audit_logs] }",
     ...
   }
   ```

2. When dirty analyzes the code, it reads the Effect Registry and treats these declarations as if they were written in the source code.

3. Functions in the source code must declare all effects from functions they call, including those defined in the Effect Registry.

## Running the example

From this directory:

```bash
# The Effect Registry will be automatically detected in the package directory
dirty .

# Or explicitly specify the Effect Registry file
DIRTY_EFFECTS_JSON=effect-registry.json dirty .
```

## Expected output

The analyzer will report an error for `ProcessUserUpdate` because it doesn't declare the `insert[audit_logs]` effect from `UpdateUserStatusInDB`:

```
example.go:40:9: function calls UpdateUserStatusInDB which has effects [insert[audit_logs], update[users]] not declared in this function
```

## Integration with external tools

This approach is particularly useful for integrating with code generation tools that can output effect information in the Effect Registry format.
