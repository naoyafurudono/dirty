# dirty

dirtyはGo言語向けのエフェクトシステムもどきです。vetツールとして用います。

## 表記

関数宣言では、それが起こすエフェクトを表明できます。

```go
//dirty: select[user] select[organization] insert[member]
func f() {}
```

上記のように `//dirty: ` から始まるスペース区切りのエフェクトラベルの列が、その関数が起こすエフェクトです。
dirtyではエフェクトラベルの集合として解釈されます。つまり、重複や順序は無視されます。

## 検査

dirtyはモジュール内の関数宣言を走査しエフェクトの表明が一貫していることを検査します。

以下のように、関数okの本体でfを呼び出す場合、okはfが起こすエフェクトを起こすと解釈します。
そのため、okのエフェクトはfのエフェクトのスーパーセットである必要があります。

```go
//dirty: select[user] select[organization] insert[member] insert[user]
func ok() {
	...
	f()
	...
}
```

したがって、以下のようにfのエフェクトを包含しないエフェクトしか表明しない場合は、エフェクトの検査が失敗します。

```go
//dirty: select[user]
func ng() {
	...
	f()
	...
}
```

表明のない関数は、検査の対象にはなりませんが、暗黙的にその関数が起こすエフェクトを計算されます。

```go
func implicit() {
	...
	f()
	...
}

//dirty: select[user] select[organization] insert[member] insert[user]
func ok() {
	...
	implicit()
	...
}

//dirty: select[user]
func ng() {
	...
	implicit()
	...
}
```

この例ではimplicitにエフェクトの表明はありません。そのためimplicitの表明に対する検証は行われません。ただしimplicitはfを呼び出すので、fのエフェクトを生じると扱われます。
ok, ngではimplicitはfを呼び出すので、結果的にそれらはfのエフェクトを生じると扱われ、それぞれの表明に対する検証に反映されます。

## 制限

実装をするのが面倒なので、今は色々な実装上のサボりをします。結果的に予期せぬ振る舞いがたくさん生じます。

- モジュール外のエフェクト表明は参照しません
- エフェクトの走査を真面目にやりません
  - 高階関数とかをサポートしません。本来なら型システムがやるようなことをするべきです。
  - 現時点では「関数宣言の中に出現した関数呼び出しのcalleeのエフェクトの和集合」をその関数宣言のエフェクトとします。
  - 無名関数の本体に囲まれていようが関係ないですし、引数として渡された関数を呼び出した場合はそのエフェクトを無視することになります。
